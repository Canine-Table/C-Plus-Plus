#include "../../headers/common-output-utils.hpp"
#include <iostream>
#include <string>

/*
    Function blueprints

    Function templates are just blueprints.
    They are not real C++ code consumed by the compiler.
    The compiler generates real C++ code by looking at the arguments you call your function template with.

    The real C++ function generated by the compiler is called a template instance

    A template instance will be reused when a similar function call (argument types) os issued.
    No duplicates are generated by the compiler.

    If template parameters are of te same type (T,T), then the arguments you call the funuction with must also match, otherwise you will get a compiler error.

    Template instances will not always do what you want.
    A good example is when you call the max_value function with pointers.
    DISASTER!

    There are tools like cppinsights.io that can help show you template instantiations.
    You can even use the debugger to infer that information from the activation record of a template function

    The arguments passed to a function template must support the operations that are done in the function body.
*/

template <typename T> T max_value(T a, T b);

int main(int argc, char **argv){

    {
        max_value(3.13,244.482);
    }

    {
        max_value(3,244);
    }

    {
        std::string x {"Hello"};
        std::string y {"World"};

        max_value("World","World"); // these are const char values not string values
        max_value(x,y);
    }

    {
        int x {5};
        int y {6};
        int *p_x {&x};
        int *p_y {&y};

        max_value(p_x,p_y); // this will be comparing memory locations not the actual values.
        max_value(*p_x,*p_y);
    }

    return 0;
}

template <typename T> T max_value(T a, T b){
    T value {(a>b) ? a : b};
    cmout::output("",value);
    return value;
}
